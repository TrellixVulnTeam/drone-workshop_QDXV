/// <reference types="node" />
import * as dgram from "dgram";
import type { BindOptions, RemoteInfo, Socket, SocketOptions } from "dgram";
import type { AddressInfo } from "net";
export interface IncomingPacket {
    msg: Buffer;
    rinfo: RemoteInfo;
}
export interface SocketAsPromisedOptions extends SocketOptions {
    dgram?: typeof dgram;
}
export declare class SocketAsPromised implements AsyncIterable<IncomingPacket> {
    readonly socket: Socket;
    _closed?: boolean;
    _errored?: Error;
    constructor(socket: Socket);
    bind(port?: number, address?: string): Promise<AddressInfo>;
    bind(options: BindOptions): Promise<AddressInfo>;
    addMembership(multicastAddress: string, multicastInterface?: string): void;
    close(): Promise<void>;
    send(msg: Buffer | string | Uint8Array | any[], port: number, address: string): Promise<number>;
    send(msg: Buffer | string | Uint8Array, offset: number, length: number, port: number, address: string): Promise<number>;
    recv(): Promise<IncomingPacket | undefined>;
    address(): AddressInfo | string;
    setBroadcast(flag: boolean): void;
    setTTL(ttl: number): void;
    setMulticastTTL(ttl: number): void;
    setMulticastInterface(multicastInterface: string): void;
    setMulticastLoopback(flag: boolean): void;
    dropMembership(multicastAddress: string, multicastInterface?: string): void;
    ref(): this;
    unref(): this;
    setRecvBufferSize(size: number): void;
    setSendBufferSize(size: number): void;
    getRecvBufferSize(): number;
    getSendBufferSize(): number;
    iterate(): AsyncIterableIterator<IncomingPacket>;
    [Symbol.asyncIterator](): AsyncIterableIterator<IncomingPacket>;
    destroy(): void;
    private readonly closeHandler;
    private readonly errorHandler;
}
export default SocketAsPromised;

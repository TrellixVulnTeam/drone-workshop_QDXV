"use strict";
/// <reference types="node" />
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketAsPromised = void 0;
class SocketAsPromised {
    constructor(socket) {
        this.socket = socket;
        this.closeHandler = () => {
            this._closed = true;
        };
        this.errorHandler = (err) => {
            this._errored = err;
        };
        socket.on("close", this.closeHandler);
        socket.on("error", this.errorHandler);
    }
    bind(arg1, arg2) {
        const socket = this.socket;
        return new Promise((resolve, reject) => {
            if (this._errored) {
                const err = this._errored;
                this._errored = undefined;
                return reject(err);
            }
            const errorHandler = (err) => {
                removeListeners();
                reject(err);
            };
            const listeningHandler = () => {
                const address = socket.address();
                removeListeners();
                resolve(address);
            };
            const removeListeners = () => {
                socket.removeListener("error", errorHandler);
                socket.removeListener("listening", listeningHandler);
            };
            socket.on("error", errorHandler);
            socket.on("listening", listeningHandler);
            try {
                socket.bind(arg1, arg2);
            }
            catch (e) {
                removeListeners();
                reject(e);
            }
        });
    }
    addMembership(multicastAddress, multicastInterface) {
        return this.socket.addMembership(multicastAddress, multicastInterface);
    }
    close() {
        return new Promise((resolve, reject) => {
            if (this._errored) {
                const err = this._errored;
                this._errored = undefined;
                return reject(err);
            }
            try {
                this.socket.once("close", () => {
                    resolve();
                });
                this.socket.close();
            }
            catch (err) {
                reject(err);
            }
        });
    }
    send(arg1, arg2, arg3, arg4, arg5) {
        return new Promise((resolve, reject) => {
            if (this._errored) {
                const err = this._errored;
                this._errored = undefined;
                return reject(err);
            }
            try {
                if (arg4 !== undefined) {
                    this.socket.send(arg1, arg2, arg3, arg4, arg5, (err, sent) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(sent);
                        }
                    });
                }
                else {
                    this.socket.send(arg1, arg2, arg3, (err, sent) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(sent);
                        }
                    });
                }
            }
            catch (err) {
                reject(err);
            }
        });
    }
    recv() {
        const socket = this.socket;
        return new Promise((resolve, reject) => {
            if (this._errored) {
                const err = this._errored;
                this._errored = undefined;
                return reject(err);
            }
            if (this._closed) {
                this._closed = undefined;
                return resolve(undefined);
            }
            const closeHandler = () => {
                removeListeners();
                resolve(undefined);
            };
            const errorHandler = (err) => {
                removeListeners();
                reject(err);
            };
            const messageHandler = (msg, rinfo) => {
                removeListeners();
                resolve({ msg, rinfo });
            };
            const removeListeners = () => {
                socket.removeListener("close", closeHandler);
                socket.removeListener("error", errorHandler);
                socket.removeListener("message", messageHandler);
            };
            socket.on("close", closeHandler);
            socket.on("error", errorHandler);
            socket.on("message", messageHandler);
        });
    }
    address() {
        return this.socket.address();
    }
    setBroadcast(flag) {
        this.socket.setBroadcast(flag);
    }
    setTTL(ttl) {
        return this.socket.setTTL(ttl);
    }
    setMulticastTTL(ttl) {
        this.socket.setMulticastTTL(ttl);
    }
    setMulticastInterface(multicastInterface) {
        this.socket.setMulticastInterface(multicastInterface);
    }
    setMulticastLoopback(flag) {
        this.socket.setMulticastLoopback(flag);
    }
    dropMembership(multicastAddress, multicastInterface) {
        this.socket.dropMembership(multicastAddress, multicastInterface);
    }
    ref() {
        this.socket.ref();
        return this;
    }
    unref() {
        this.socket.unref();
        return this;
    }
    setRecvBufferSize(size) {
        this.socket.setRecvBufferSize(size);
    }
    setSendBufferSize(size) {
        this.socket.setSendBufferSize(size);
    }
    getRecvBufferSize() {
        return this.socket.getRecvBufferSize();
    }
    getSendBufferSize() {
        return this.getSendBufferSize();
    }
    iterate() {
        const socketAsPromised = this;
        let wasEof = false;
        return {
            [Symbol.asyncIterator]() {
                return this;
            },
            async next() {
                if (wasEof) {
                    return { value: "", done: true };
                }
                else {
                    const value = await socketAsPromised.recv();
                    if (value === undefined) {
                        wasEof = true;
                        return { value: "", done: true };
                    }
                    else {
                        return { value, done: false };
                    }
                }
            },
        };
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    destroy() {
        const socket = this.socket;
        if (socket) {
            socket.removeListener("close", this.closeHandler);
            socket.removeListener("error", this.errorHandler);
        }
    }
}
exports.SocketAsPromised = SocketAsPromised;
exports.default = SocketAsPromised;
//# sourceMappingURL=socket-as-promised.js.map